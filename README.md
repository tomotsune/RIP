# 实验项目四 RIP协议的模拟实现

## 实验目的

内部网关协议RIP中，路由表更新的原则是找出到每个目的网络的最短距离，这种更新算法又称为距离向量算法，掌握该算法对于理解路由的机制有很大的帮助。

## 实验环境

（1）运行windows 2007/xp操作系统的PC一台.

（2）每台PC机安装有visual C++、java编程环境或其他开发环境.

## 实验步骤及内容

- 修改相邻路由器发来的RP报文中**所有表项**
  对地址为X的相邻路由器发来的RIP报文,修改此报文中的所有项目:把“下一跳”字段中的地址改为X, 并把**所有的“距离”字段+1**
- 对修改后的RP报文中的每一个项目,进行以下步骤:
    - R1路由表中若没有Net3,则把该项目填入R1路由表
    - R1路由表中若有Net3,则查看下一跳路由器地址:
        - 若下一跳是X,则用收到的项目替换源路由表中的项目
        - 若下一跳不是X,原来距离比从X走的距离远则更新,否则不作处理。
- 若**180s**还没收到相邻路由器X的更新路由表,则把X记为不可达的路由器,即把距离设置为16。
- 返回 (间隔30秒继续)

## 实验分析，回答下列问题

假定网络中的路由器B的路由表有如下的项目（这三列分别表示目的网络、距离和下一跳路由器）

N1   5   A

N2   3   C

N6   6   F

N8   4   E

现在B收到从C发来的路由信息

N1   5  -

N2   4  -

N3   8  -

N6   4  -

N8   3  -

  - 试用已编写的程序求出路由器B更新后的路由表。（说明每一个更新的原因）

    N1   5   A 	更短

    N2   5   C	 更新

    N3   9   C	新路由

    N6   5   C	更短

    N8   4   E	距离不变

- 试着演示当网络出现故障时，要经过比较长的时间才能将此信息传送到所有路由器的过程。（好消息传播的快，坏消息传播的慢）

  C路由器初始路由表:[{N1 5 -} {N2 ==16== B} {N3 8 -} {N6 4 -} {N8 3 -}]

  C<=B: [{N1 5 A} {N2 ==3== C} {N6 6 F} {N8 4 E}]
  
  C更新后的路由表:[{N1 5 -} {N2 ==4== B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C=>B: [{N1 5 -} {N2 4 B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C<=B: [{N1 5 A} {N2 ==5== C} {N6 5 C} {N8 4 E} {N3 9 C}]
  
  C更新后的路由表:[{N1 5 -} {N2 ==6== B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C=>B: [{N1 5 -} {N2 6 B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C<=B: [{N1 5 A} {N2 ==7== C} {N6 5 C} {N8 4 E} {N3 9 C}]
  
  C更新后的路由表:[{N1 5 -} {N2 ==8== B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C=>B: [{N1 5 -} {N2 8 B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C<=B: [{N1 5 A} {N2 ==9== C} {N6 5 C} {N8 4 E} {N3 9 C}]
  
  C更新后的路由表:[{N1 5 -} {N2 ==10== B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C=>B: [{N1 5 -} {N2 10 B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C<=B: [{N1 5 A} {N2 ==11== C} {N6 5 C} {N8 4 E} {N3 9 C}]
  
  C更新后的路由表:[{N1 5 -} {N2 ==12== B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C=>B: [{N1 5 -} {N2 12 B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C<=B: [{N1 5 A} {N2 ==13== C} {N6 5 C} {N8 4 E} {N3 9 C}]
  
  C更新后的路由表:[{N1 5 -} {N2 ==14== B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C=>B: [{N1 5 -} {N2 14 B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C<=B: [{N1 5 A} {N2 ==15== C} {N6 5 C} {N8 4 E} {N3 9 C}]
  
  C更新后的路由表:[{N1 5 -} {N2 ==16== B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C=>B: [{N1 5 -} {N2 16 B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C<=B: [{N1 5 A} {N2 ==16== C} {N6 5 C} {N8 4 E} {N3 9 C}]
  
  C更新后的路由表:[{N1 5 -} {N2 ==16== B} {N3 8 -} {N6 4 -} {N8 3 -}]
  
  C=>B: [{N1 5 -} {N2 16 B} {N3 8 -} {N6 4 -} {N8 3 -}]

- 路由表的动态变化，按照时间定期更新路由表，直到稳定为止。

  - B更新后的路由表 (收敛)

      N1   5   A

      N2   5   C

      N3   9   C

      N6   5   C

      N8   4   E

  - C更新后的路由表(收敛)

    N1   5   -

    N2   4   -

    N3   8   -

    N6   4   -

    N8   3   -
